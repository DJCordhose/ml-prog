<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>ML vs Prog</title>

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="reveal/reset.css">
		<link rel="stylesheet" href="reveal/reveal.css">
		<!-- <link rel="stylesheet" href="reveal/theme/black.css" id="theme"> -->
		<link rel="stylesheet" href="reveal/theme/solarized.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="reveal/plugin/highlight/monokai.css" id="highlight-theme">
		<!-- <link rel="stylesheet" href="reveal/plugin/highlight/zenburn.css" id="highlight-theme"> -->

		<style>

	.reveal h1,
	.reveal h2,
    .reveal h3,
    .reveal h4 {
		font-family: 'Calibri', sans-serif;
		letter-spacing: -2px;

			font-weight: bold;
			color: black;
			font-style: italic;
			text-transform: none !important;
    }


    .reveal pre code {
      max-height: 450px !important;
    }

	.todo:before {
      content: 'TODO: ';
    }

    .todo {
      color: red !important;
    }

    img {
      max-height: 400px !important;
    
    }


		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<!-- 
Machine Learning: ein Programm, das ein Programm schreibt

In der klassischer Software-Entwicklung schreibt ein Entwickler anhand von Anforderungen ein Programm. Im Machine
Learning kann eine Lern-Strategie anhand von Daten ebenfalls ein Programm schreiben. Dies ist nicht offensichtlich, da
ein manuell geschriebenes Programm aus Code besteht, während ein Machine Learning Modell davon abstrakt ist.

In diesem Talk mache ich diesen Ansatz explizit indem ich aus einem abstrakten Machine Learning Modell Code generiere.
Dabei lösen wir zusammen eine gegebene Aufgabe mit klassischer Programming, und trainieren zusätzliche ein Modell anhand
von Daten. Am Ende vergleichen wir unseren handgeschriebenen Code mit dem erzeugten anhand von Qualitätsmerkmalen wie
Lesbarkeit, Wartbarkeit, Testbarkeit und Interpretierbarkeit, wie gut die Aufgabe gelöst wird, etc. Als Bonus nutzen wir
unseren selbst geschriebenen Code als Lehrer für das Machine Learning Modell und führen eine etwas sonderbare Art des
Refactorings durch.
 -->

<section data-markdown class="preparation">
### preparation

- Open Notebook: https://colab.research.google.com/drive/183bcemb82wAckph5DKfv2qTp6Spac3w_#scrollTo=gKxCb0NoOQjM  
</section>


<section data-markdown class="todo">
- bit.ly-Link
</section>


<section data-markdown class="todo">
Metriken auf Code anwenden
  </section>
  

<section data-markdown class="todo">
### Induction

- Phil PhD: https://sgfin.github.io/2020/06/22/Induction-Intro/
  - https://twitter.com/IAmSamFin/status/1353404287540289536
- https://twitter.com/ChristophMolnar/status/1353325765346123777
</section>


<section data-markdown class="todo">
### Framework für Wahrscheinlichkeiten einbauen

Adhoc
Blobs, in der Mitte, der 0815 Farer
Verläufe, nimmt ab 65 ab, nimmt zu je schneller die Karre, nimmt mit zunehmendem Alter ab
</section>

<section data-markdown>
## Machine Learning
### ein Programm, das ein Programm schreibt

</section>

<section data-markdown>
### Roadmap

![](img/sketch.png)
</section>
	

<section data-markdown>
  <textarea data-template>
### Our Scenario for today: Predicting Risk

* We are CTO of a highly innovative Car Insurance Company
* Different from other insurance companies we determine the rate by the actual number of accidents per customer
* _Objective: how many accidents will prospective customers have?_ 

<img src='img/pixabay/accident-151668_1280.png' height="300px">
  </textarea>
</section>

<section data-markdown>
### We have some data

![](img/1-risk-data.png)
</section>
  
<section data-markdown>
### Random Decision Boundaries

![](img/2-random-model.png)

Background color indicates prediction
</section>
  
<section data-markdown>
  <textarea data-template>
### And let's introduce a metric for quality of any prediction        

<script type="math/tex; mode=display">
accuracy = {\frac {correct\;predictions}{number\;of\;samples}}
</script>

</textarea>
</section>

<section data-markdown>
### Accuracy for guessing is just 1/3 = 33%
  
![](img/2-random-model.png)
  </section>

  <section data-markdown>
## We know something about the real world, let us express this as a set of rules
	</section>
	
	
<section>
<h3>A first sketch</h3>
<pre>
  <code>
  if speed < 100:
    return low
  if speed > 140:
    return high
  return medium
</code></pre>

<img src='img/3-rule-based-model.png' height="300" class="fragment">
<br>

<a  class="fragment"
href='https://colab.research.google.com/drive/183bcemb82wAckph5DKfv2qTp6Spac3w_?hl=en#scrollTo=LEt_LUcSbLhG'>
  We can do better, let's try together
</a>
</section>

<section data-markdown>
### Best Model I could come up with
  
![](img/4-rule-based-model.png)

68% accuracy
  </section>

  <section data-markdown class="fragments">
### Taking one step back
  
* this was daten driven development
* no formal specification given
* was this test driven? 
* test implicitly defined by data?
* if so, why did we not achieve 100%?
* should we?

  </section>

  <section data-markdown>
### This model is close to a perfect score
  
![](img/knn.png)

96% accuracy, not perfect because of ambiguities
      </section>
    

<section data-markdown>
## Should we try to achieve 100% accuracy?

Is the previous model better than ours?
  </section>

<section data-markdown>
## Let's simulate production

![](img/generalization.jpg)


Part of the known data has been held back for evaluation
</section>

  <section data-markdown>
### Applying the "perfect" model on evaluation data

![](img/knn-test.png)

only 60% accuracy on unknown data

      </section>
    
  <section data-markdown>
### And now our rule based model

![](img/rules-test.png)

66% accuracy is better and close to original score on known data

      </section>
  

  <section data-markdown class="fragments">
### We have optimized for the wrong metric

* our metric: accuracy on known data
* if data is unambiguous we can always achieve 100%
* but we want the model to perform well on real world data
* we need to work with what we have so we hold back some data
* that data is not used for training, but for evaluation
* scores on that data and the difference to training scores is what really matters
  </section>

  <section data-markdown>
### Data and the World
  
![](img/data-and-the-world.jpg)

even that approach is not ideal, but the best we have

  </section>

  <section data-markdown class="fragments">
### Overfitting and Underfitting

* if score on training data is better than on test we call this overfitting
* hand written rules tend to not overfit
* when scores are obviously worse than they could be, we call this underfitting
* hand written rules tend to underfit
* other approaches have other tendencies
* you want to avoid both
* depending on approach you need different measures for avoiding overfitting and underfitting
  </section>


    <section data-markdown>
### Where did the "good" model come from?
  
* the "strong" model was generated by machine learning using a naive nearest neighbor approach
* turned into rules it would have been a nested if then else 
* that if-then-else would be 19 levels deep
* we can still turn it back into explicit rules just for the fun of it
  </section>

<section>
<h3>Just a fraction and only 5 levels deep</h3>
<pre>
  <code>
def nested_tree(speed, age):
  if age <= 67.5:
    if age <= 36.5:
      if speed <= 106.5:
        if age <= 30.5:
          if speed <= 100.5:
            return medium
          else:  # if speed <= 100.5
            return medium
        else:  # if age <= 30.5
          if speed <= 91.5:
            return medium
          else:  # if speed <= 91.5
            return low
...
</code></pre>

<p>Any idea what is wrong with this code?</p>
</section>

<section data-markdown>
### From Assumptions to ML Model 
	
* There is an infinite number of possible decision boundaries
* How should we constrain induction to get to a desired one?
* How can we infer from post to future or from known to unknown?
	
	  </section>
	
	
	


			</div>

		</div>

		<script src="reveal/reveal.js"></script>
		<script src="reveal/jquery-3.5.1.min.js"></script>
		<script>
			const isLocal =
			  window.location.hostname.indexOf("localhost") !== -1 ||
			  window.location.hostname.indexOf("127.0.0.1") !== -1;
	  
        // https://revealjs.com/slide-visibility/
      if (isLocal) {
        $(".preparation").attr("data-visibility", "uncounted");
			  $(".todo").attr("data-visibility", "uncounted");
			} else {
			  // only applies to public version
        $(".preparation").attr("data-visibility", "hidden");
			  $(".todo").attr("data-visibility", "hidden");
			}
			Reveal.addEventListener("ready", function(event) {
			  $(".fragments li").addClass("fragment");
			  $(".no-fragments li").removeClass("fragment");
	  
			  // make all links open in new tab
			  $("a").attr("target", "_blank");
	  
			  if (isLocal) {
				// only applies to presentation version
				// Reveal.configure({ controls: false });
			  } else {
				// only applies to public version
				$(".fragment").removeClass("fragment");
        }
        
      });
      
			  // applies to all versions
  			// $('section').attr('data-background-image', "backgrounds/sky.jpg");
			  $("code").attr("data-line-numbers", true);
			  $("code").attr("data-trim", true);
			  $("code").attr("contenteditable", true);
	  
		</script>
	  
		<script src="reveal/plugin/zoom/zoom.js"></script>
		<script src="reveal/plugin/notes/notes.js"></script>
		<script src="reveal/plugin/search/search.js"></script>
		<script src="reveal/plugin/markdown/markdown.js"></script>
		<script src="reveal/plugin/highlight/highlight.js"></script>
		<script src="reveal/plugin/math/math.js"></script>


		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,
				// width: "100%",
				// height: "100%",


				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight, RevealMath ]
			});

		</script>

	</body>
</html>
